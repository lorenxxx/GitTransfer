## 全局统一异常处理的使用方式和源码解析

### 前言

异常处理是开发过程中一个不可避免的问题，你是否写过这样的代码？你是否还在写这样的代码？你是否已经厌倦写这样的代码？
<pre>
<code>
@RestController
@RequestMapping(value = "/api/v1/tasks")
@Slf4j
public class TaskController implements ITaskController {
  
  	@Autowired
  	private ITaskService taskService;
  
    @PostMapping
  	@Override
    public Result<String> addTask(@RequestBody AddTaskDTO task) {

        
            taskService.addTask(task);
          	...
            result = Result.success("新增成功");  
        } catch (IllegalArgumentException e) {
            result = Result.fail("参数错误");
        } catch (PermissionException e) {
            result = Result.fail("权限校验失败");
        } catch (BusinessException e) {
        	result = Result.fail("业务异常");
        } catch (Exception e) {
            result = Result.fail("未知错误");
        }

        return result;
    }
	
}
</code>
</pre>
看看这无止境的try...catch...，全局统一异常处理了解一下？

统一异常处理是一种非常方便的异常处理方式，能够简化控制层和服务层的代码。让我们上图来对比一下。
<pre>
<code>
@RestController
@RequestMapping(value = "/api/v1/tasks")
@Slf4j
public class TaskController implements ITaskController {
  
  	@Autowired
  	private ITaskService taskService;
  
    @PostMapping
  	@Override
    public Result<String> addTask(@RequestBody AddTaskDTO task) {
    	taskService.addTask(task);
        return Result.sucess("新增成功");
    }
	
}
</code>
</pre>

现在比较流行的两种全局异常处理的方式：
##
* HandlerExceptionResolver接口
* @ControllerAdvice注解

本文将介绍这两种使用方式，并从源码上分析@ControllerAdvice注解实现原理。

### 准备工作
首先，我们先自定义一个异常，用来代表应用可能会产生的业务异常。
<pre>
<code>
@Slf4j
public class BusinessException extends RuntimeException implements IException2Result {

    private static final long serialVersionUID = 5917336312549960151L;

    public BusinessException() {
        super();
    }

    public BusinessException(String message) {
        super(message);
    }

    public BusinessException(String message, Throwable cause) {
        super(message, cause);
    }

    public Result<String> process() {
        log();
        return resolve();
    }

    @Override
    public void log() {
        log.error(this.getMessage(), this);
    }

    @Override
    public Result<String> resolve() {
        return Result.fail(this.getMessage() == null ? ToastConstants.SERVICE_INTERNAL_ERROR : this.getMessage());
    }

}
</code>
</pre>
同时可以在此异常的基础上通过继承进行扩展，以满足自己的需要。

#### HandlerExceptionResolver接口的使用方式
我们先来看一下HandlerExceptionResolver接口的源码。
<pre>
<code>
public interface HandlerExceptionResolver {

	/**
	 * Try to resolve the given exception that got thrown during handler execution,
	 * returning a {@link ModelAndView} that represents a specific error page if appropriate.
	 * <p>The returned {@code ModelAndView} may be {@linkplain ModelAndView#isEmpty() empty}
	 * to indicate that the exception has been resolved successfully but that no view
	 * should be rendered, for instance by setting a status code.
	 * @param request current HTTP request
	 * @param response current HTTP response
	 * @param handler the executed handler, or {@code null} if none chosen at the
	 * time of the exception (for example, if multipart resolution failed)
	 * @param ex the exception that got thrown during handler execution
	 * @return a corresponding {@code ModelAndView} to forward to, or {@code null}
	 * for default processing
	 */
	ModelAndView resolveException(
			HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex);

}
</code>
</pre>

该接口只定义了一个resolveException方法，我们需要做的就是自定义一个统一异常处理类并实现该接口，如下图所示：
<pre>
<code>
@Order(-1000)
public class ExceptionResolver implements HandlerExceptionResolver {
    
    @Override
    public ModelAndView resolveException(HttpServletRequest request,
            HttpServletResponse response, Object handler, Exception ex) {
        Result<String> result = new Result();
       
        if(ex instanceof BussinessException) {
            resolverBussinessException(ex, sb, result);
        } else {
            resolverOtherException(ex, sb, result); 
        }
        
        result.setSuccess(Boolean.False);
        result.setData(ex.getMessage());
        
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        response.setCharacterEncoding("UTF-8");
        response.setHeader("Cache-Control", "no-cache, must-revalidate");  
        try {
            response.getWriter().write(JSON.toJSONString(result));
        } catch (IOException e) {
            logger.error("与客户端通讯异常：" + e.getMessage(), e);
        }
        
        logger.debug("异常：" + ex.getMessage(), ex);
        
        return new ModelAndView();
	}
  
}
</code>
</pre>
resovleException方法负责解析并处理异常，可以在这里面实现自定义的异常处理逻辑，值得一提的是，该方法返回ModelAndView，所以对于前后端分离的开发场景，需要手动打开流并写回JSON格式。另外需要注意的是，需要在这个类上加上@Order注解，因为Spring默认有三个异常拦截器，里面的order属性分别为0，1，2，当异常被捕获时，会首先去这三个拦截器中找匹配的异常，若有匹配的，则不会执行我们自定义的异常处理器。@Order(-1000)的作用就是将顺序提到第一位，先加载我们的，有符合异常条件的，则不会继续走其他三个默认的。若请求没报异常，则此类的resovleException方法是不会运行的。

#### @ControllerAdvice注解的使用方式
这种方式相对于上一种来说更加简单，代码更加清晰易懂，定义一个全局统一异常处理类，如下图所示：
<pre>
<code>
@ControllerAdvice
@Order(-1000)
@Slf4j
public class UnitedExceptionHandleAdvice {

    @ExceptionHandler(BusinessException.class)
    @ResponseBody
    public Result<String> handleBusinessException(BusinessException e) {
        return e.process();
    }

    @ExceptionHandler(Exception.class)
    @ResponseBody
    public Result<String> handleOtherException(Exception e) {
        return processDefault(e);
    }

    private static Result<String> processDefault(Exception e) {
        log.error(e.getMessage(), e);
        return Result.fail(ToastConstants.SERVICE_INTERNAL_ERROR);
    }

}
</code>
</pre>
在这个类上加上@ControllerAdvice注解，同时加上@Order(-1000)，原理同上。在类中定义异常处理方法，并配合@ExceptionHandler注解，指明这个方法可以处理哪一种类型的异常。同时配合@ResponseBody注解，可以轻松的返回JSON格式的数据。

推荐使用@ControllerAdvice注解的方式实现全局统一异常处理。

#### @ControllerAdvice实现源码解析

首先来看看这个注解的源码。
<pre>
<code>
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component
public @interface ControllerAdvice {

	@AliasFor("basePackages")
	String[] value() default {};

	@AliasFor("value")
	String[] basePackages() default {};

	Class<?>[] basePackageClasses() default {};

	Class<?>[] assignableTypes() default {};

	Class<? extends Annotation>[] annotations() default {};

}
</code>
</pre>
非常简单，表面上看不出任何的功能的实现，但是注意它的Retention是Runtime。

接下来，我们先模拟一个请求，这个请求会在处理的过程中会抛出一个异常，这个异常会被统一异常切面捕捉到，然后进行相应的处理，让我们一步步Debug，看清楚整个请求的处理过程。


。。。
。。。
。。。

好了，通过上面的Debug，我们找到了统一异常切面的核心点所在：ExceptionHandlerExceptionResolver类的exceptionHandlerAdviceCache属性。
接下来先看看ExceptionHandlerExceptionResolver的部分相关源码，以此来弄清楚exceptionHandlerAdviceCache是如何初始化的。
可以看到，ExceptionHandlerExceptionResolver实现了InitializingBean接口，这个接口只定义一个afterPropertiesSet方法，如下图所示：
<pre>
<code>
public interface InitializingBean {
	void afterPropertiesSet() throws Exception;
}
<code>
</pre>
这个接口的作用就是在Spring容器初始化bean的时候完成一些初始化操作。ExceptionHandlerExceptionResolver实现了该方法，并在该方法中完成了对exceptionHandlerAdviceCache的初始化，我们来看一下其关键的部分：通过ControllerAdviceBean.findAnnotatedBeans方法从上下文中找出所有注解了@ControllerAdvice的类，如下图所示：
<pre>
<code>
public class ControllerAdviceBean implements Ordered {
	public static List<ControllerAdviceBean> findAnnotatedBeans(ApplicationContext applicationContext) {
		List<ControllerAdviceBean> beans = new ArrayList<ControllerAdviceBean>();
		for (String name : BeanFactoryUtils.beanNamesForTypeIncludingAncestors(applicationContext, Object.class)) {
			if (applicationContext.findAnnotationOnBean(name, ControllerAdvice.class) != null) {
				beans.add(new ControllerAdviceBean(name, applicationContext));
			}
		}
		return beans;
	}
}
<code>
</pre>

找到之后封装成ExceptionHandlerMethodResolver，装载到exceptionHandlerAdviceCache中，从而完成初始化动作。应用启动后，对于请求抛出的异常，将在这里面寻找合适的方法进行处理。

### 总结




### 参考资料
* https://www.jianshu.com/p/da311ae29908
* 